Статья для qa-специалистов о поиске в ElasticSearch
Structured Query в плагине ElasticSearch Head.

ElasticSearch - это нереляционное хранилище документов в JSON-формате и поисковой системой на базе полнотекстового Lucene-поиска. Elasticsearch разработан компанией Elastic одновременно со связанными проектами (их называют Elastic Stack) — Logstash, Elasticsearch, Beats, Kibana. 
Kibana осуществляет визуализацию данных через web-интерфейс. Beats — это отправители данных с разных устройств и легковесные агенты. Logstash обеспечивает сбор и обработку данных зарегистрированных событий. Что касается хранения и поиска данных, то за них отвечает Elasticsearch.
Для работы с ElasticSearch используются API (ссылка на документацию
https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html)

Существуют также и инструменты с графическим интерфейсом, в том числе бесплатные расширения для браузера. Самым популярным из них согласно данным интернет-магазина Chrome ElasticSearch Head от TravisTX, возможностям поиска в котором посвящен данный материал.

Немного теории.

Классическое сравнение элементов ElasticSearch с базами данных выглядит так:
Elasticsearch SQL MongoDB
Index Database  Database
Mapping/Type  Table Collection
Field Column  Field
Object(JSON)  Tuple Object(BSON)

https://codedzen.ru/elasticsearch-vvedeniye-1-1-osnovnyye-ponyatiya/
В Elasticsearch данные хранятся в виде документов JSON (Javascript Object Notation). Большинство хранилищ данных NoSQL используют JSON для хранения своих данных, поскольку формат JSON очень лаконичный, гибкий и понятный людям. Документ в Elasticsearch очень похож на строку по сравнению с реляционной базой данных.
Тип похож на таблицу базы данных, индекс может иметь один или несколько типов. Тип — это логическое разделение различных видов данных. Например, если вы создаете приложение для блога, можно предложить создать тип для статей и комментариев.
Индекс похож на базу данных. Термин индекс не следует путать с индексом базы данных, как можно предложить если вы знакомы с реляционными базами данных. Индекс подразумевает логическую группировку Типов (таблиц).

https://losst.ru/ispolzovanie-elasticsearch
Если вы хотите сделать выборку по нескольким полям и использовать для этого операторы AND и OR, то вам понадобится конструкция bool. Синтаксис её такой:

"query": {
  "bool" : {
    "must" : [
         {"поле1" : "условие"},
         {"поле2" : "условие"},
    ],
    "filter": {},
    "must_not" : {}
    "should" : {}
  }
}

Обратите внимание на синтаксис. Поскольку у нас два элемента подряд, мы используем массив []. Но так как дальше нам снова нужно создавать пары ключ:значение, то в массиве открываются фигурные скобки. Конструкция bool объединяет в себе несколько параметров:

must - все условия должны вернуть true;
must_not - все условия должны вернуть false;
should - одно из условий должно вернуть true;
filter - то же самое что и match, но не влияет на оценку релевантности.

В Elasticsearch существует несколько типов поиска. Основные из них:

term - точное совпадение искомой строки со строкой в индексе или термом;
match - все слова должны входить в строку, в любом порядке;
match_phrase - вся фраза должна входить в строку;
query_string - все слова входят в строку в любом порядке, можно искать по нескольким полям, используя регулярные выражения;

wildkart
prefix
fuzzy
range
text
missing



https://otus.ru/nest/post/1550/
Elasticsearch — что это?
Elasticsearch представляет собой кластерную NoSQL с JSON REST API. Его можно назвать нереляционным хранилищем документов в JSON-формате и поисковой системой на базе полнотекстового Lucene-поиска.


https://otus.ru/nest/post/1550/
Elasticsearch разработан компанией Elastic одновременно со связанными проектами (их называют Elastic Stack) — Logstash, Elasticsearch, Beats, Kibana. 
Kibana осуществляет визуализацию данных через web-интерфейс. Beats — это отправители данных с разных устройств и легковесные агенты. Logstash обеспечивает сбор и обработку данных зарегистрированных событий. Что касается хранения и поиска данных, то за них отвечает Elasticsearch. 


https://xakep.ru/2015/06/11/elasticsearch-tutorial/
"Elasticsearch поддерживает несколько различных способов нечеткого поиска:

match query + fuzziness option. Добавление параметра нечеткости к обычному запросу на совпадение. Анализирует текст запроса перед поиском;
fuzzy query. Нечеткий запрос. Лучше избегать его использования. Больше похож на поиск по стеммам. Анализ текста запроса перед поиском не производится;
fuzzy_like_this/fuzzy_like_this_field. Запрос, аналогичный запросу more_like_this, но поддерживающий нечеткость. Также поддерживает возможность анализа весов для лучшего ранжирования результатов поиска;
suggesters. Предположения — это не совсем тип запроса, скорее другая операция, работающая изнутри на нечетких запросах. Может использоваться как совместно с обычными запросами, так и самостоятельно."


https://losst.ru/ispolzovanie-elasticsearch
6. ПОИСК ПО ИНДЕКСУ
Для поиска или, другими словами, выборки данных в Elasticsearch используется команда _search. Если вызвать команду без параметров, то будут обрабатываться все документы. Но выведены будут только первые 10, потому что это ограничение по умолчанию:

curl -XGET 'http://localhost:9200/shakespeare/doc/_search?pretty'
Здесь мы выбрали первые десять документов из индекса shakespeare и таблицы doc. Чтобы выбрать больше, передайте параметр size со значением, например 10000:

curl -XGET 'http://localhost:9200/shakespeare/doc/_search?size=10000&pretty'

Самый простой пример поиска - передать поисковый запрос в параметре q. При этом поиск Elasticsearch будет выполняться во всех полях индекса. Например, найдём все, что касается Эдгара (EDGAR):

curl -XGET 'http://localhost:9200/shakespeare/doc/_search?q=EDGAR&pretty '

Но как вы понимаете, всё это очень не точно и чаще всего надо искать по определённым полям. В Elasticsearch существует несколько типов поиска. Основные из них:

term - точное совпадение искомой строки со строкой в индексе или термом;
match - все слова должны входить в строку, в любом порядке;
match_phrase - вся фраза должна входить в строку;
query_string - все слова входят в строку в любом порядке, можно искать по нескольким полям, используя регулярные выражения;
Синтаксис term такой:

"query" {
  "term" {
    "имя_поля": "что искать"
  }
}

Например, найдем записи, где говорит Эдгар с помощью term:

vi elastic_searchterm.sh

#!/bin/bash
curl -XGET 'http://localhost:9200/shakespeare/doc/_search?pretty ' -H 'Content-Type: application/json' -d '
{
"query" : {
"term" : {
"speaker.keyword" : "EDGAR"
}
}
}'

sh elastic_searchterm.sh
Мы нашли десять реплик, которые должен сказать Эдгар. Дальше испытаем неточный поиск с помощью match. Синтаксис такой же, поэтому я его приводить не буду. Найдём предложения, которые содержат слова of love:

#!/bin/bash
curl -XGET 'http://localhost:9200/shakespeare/doc/_search?pretty ' -H 'Content-Type: application/json' -d '
{
"query" : {
"match" : {
"text_entry" : "love of"
}
}
}'
С query_string и match_phrase разберётесь сами, если будет нужно.

8. ОПЕРАТОРЫ AND И OR ДЛЯ ПОИСКА
Если вы хотите сделать выборку по нескольким полям и использовать для этого операторы AND и OR, то вам понадобится конструкция bool. Синтаксис её такой:

"query": {
  "bool" : {
    "must" : [
         {"поле1" : "условие"},
         {"поле2" : "условие"},
    ],
    "filter": {},
    "must_not" : {}
    "should" : {}
  }
}

Обратите внимание на синтаксис. Поскольку у нас два элемента подряд, мы используем массив []. Но так как дальше нам снова нужно создавать пары ключ:значение, то в массиве открываются фигурные скобки. Конструкция bool объединяет в себе несколько параметров:

must - все условия должны вернуть true;
must_not - все условия должны вернуть false;
should - одно из условий должно вернуть true;
filter - то же самое что и match, но не влияет на оценку релевантности.
Например, отберём все записи, где Helen говорит про любовь:

vi elastic_searchbool.sh

#!/bin/bash
curl -XGET 'http://localhost:9200/shakespeare/doc/_search?pretty ' -H 'Content-Type: application/json' -d '
{
"query" : {
"bool" : {
"must": [
{"match" : {
"text_entry" : "love"
}},
{"match": {
"speaker": "helen"
}}
]
}
}
}'

Как видите, найдено только два результата.

9. ГРУППИРОВКА
И последнее, о чём мы сегодня поговорим, - группировка записей в Еlasticsearch и суммирование значений по ним. Это аналог запроса GOUP BY в MySQL. Группировка выполняется с помощью конструкции aggregations или aggs. Синтаксис её такой:

"aggregations" : {
  "название" : {
     "тип_группировки" : {
        параметры
     },
     дочерние_группировки
  }
}

Разберём по порядку:

название - указываем произвольное название для данных, используется при выводе;
тип_группировки - функция группировки, которая будет использоваться, например terms, sum, avg, count и так далее;
параметры - поля, которые будем группировать и другие дополнительные параметры;
дочерние группировки - в каждую группировку можно вложить ещё одну или несколько других таких же группировок, что делает этот инструмент очень мощным.
Давайте подсчитаем, сколько отдельных реплик для каждого человека. Для этого будем использовать группировку terms:

vi elastic-group.sh

#!/bin/bash
curl -XGET 'http://localhost:9200/shakespeare/doc/_search?pretty&size=10000 ' -H 'Content-Type: application/json' -d '
{
"aggs" : {
"replics" : {
"terms": {
"field": "speaker.keyword"
}
}
}
}'

В результате запроса Еlasticsearch получим:
Сначала пойдут все найденные документы, а затем в разделе aggregations мы увидим наши значения. Для каждого имени есть doc_count, в котором содержится количество вхождений этого слова. Чтобы продемонстрировать работу вложенных группировок, давайте найдём сумму и среднее значение поля line_number для каждого участника:

#!/bin/bash
curl -XGET 'http://localhost:9200/shakespeare/doc/_search?pretty&size=10000 ' -H 'Content-Type: application/json' -d '
{
"aggs" : {
"replics" : {
"terms": {
"field": "speaker.keyword"
},
"aggs" : {
"total_number": {
"sum": {"field": "line_id"}
},
"avg_number": {
"avg": {"field": "line_id"}
}
}
}
}
}'
В сумме у нас очень большие числа, поэтому они отображаются в экспоненциальном формате. А вот в среднем значении всё вполне понятно.

{
"key" : "DUKE VINCENTIO",
"doc_count" : 909,
"total_number" : {
"value" : 5.4732683E7
},
"avg_number" : {
"value" : 60211.97249724973
}
}
Тут key - имя персонажа, total_number.value - сумма поля, avg_number.value - среднее значение поля.


https://www.bigdataschool.ru/blog/elasticsearch-bdam-business-case.html
Как найти иголку в стоге сена: примеры полнотекстового поиска в Elasticsearch
В Elasticsearch существует два контекста, в которых работает поиск [1]:

Query, который работает как полнотекстовый поиск и позволяет находить похожие на запрашиваемые значения в больших объемах текста. Благодаря анализаторам query-запросы позволяют искать по словоформам (так называемый «нечеткий поиск»), исключать стоп-слова и пр. При выполнении query-запросов для каждого документа вычисляется рейтинг – численное значение того, насколько документ подходит под запрос. Результаты в выдаче сортируются в порядке убывания этого рейтинга.
Filter, который позволяет выполнять поиск по точному значению для фильтрации документов. Filter-запросы кешируются и отрабатывают быстрее, чем query-запросы.
Примечательно, что полнотекстовый поиск позволяет находить документы не по точному совпадению значений определенных полей с заданным в запросе, а именно по текстовому содержимому всех полей. В рассматриваемом кейсе интернет-магазина это особенно важно, т.к. в названии товаров могут встречаться опечатки, например, «корушка» вместо «кормушка» и т.д.

В Elasticsearch полнотекстовый поиск основан на инвертированном индексе — структуре данных, которая содержит все слова из датасета и списки с документами, где встречаются эти слова – термы, что выдает анализатор после обработки входного текста. При полнотекстовом поиске движок ES обращается только к инвертированному индексу, поэтому не получится найти точное совпадение фразы без использования анализаторов по строкам целиком. Поэтому еще на этапе создания маппинга (схемы) индекса следует предусмотреть назначение рассматриваемых полей. В частности, числа или даты индексировать без анализаторов, а для текстовых полей, которые не являются перечислением небольшого набора значений, стоит тщательно выбирать метод анализ, который напрямую влияет на результаты поиска [1]. Проводя аналогию с реляционными СУБД, можно сказать, что индекс — это база данных, а тип — это отдельная таблица в ней. Каждый тип имеет свою схему (маппинг, mapping), который генерируется автоматически при индексации документа [2]. Тем не менее, при формировании поисковых запросов к Elasticsearch индекс не является обязательным параметром, но он ускоряет поиск. При отсутствии указания конкретного индекса поиск будет осуществлять по всем данным, что есть в базе, а это долго.

Возвращаясь к рассматриваемому примеру, посмотрим, как будет выглядеть запрос к Elasticsearch, которой вернет список имен и емейлов именно тех клиентов, кто покупал товары для кошек и собак. Зададим все возможные словоформы: «кошк» (для слов «кошка», «кошки», «кошек»), «кот» (для слов «кот», «кота», коты), аналогично «собак», «пс» («пса», «псов», «псы»), «пес», «пёс»).

POST index_usecase/_search

{  

«_source»: [

     «clientEmail«,

     «clientName»  

],  

«query»: { 

    «terms»: {

       «productName» : [«кот«,»кош«, «пс«, «пес«, «пёс«]    

}

   }

}

Избежать ручного перечисления возможных словоформ позволят специальные морфологические плагины, которые приводят близкие слова к одному и тому же токену, например, «люди/человек», «пес/собака» и пр. В частности, для русского языка это плагин russian_morphology [2].

Параметр fuzziness позволит найти слова с опечатками, задав число возможных несовпадающих символов в терме [1].

{

    «query»: {

        «match»: {

            «question»: {

                «query»: «fulltext search»,

                «fuzziness»: 1,

            }

        }

    }

}